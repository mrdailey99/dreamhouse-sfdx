"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const appInsights = require("applicationinsights");
const child_process_1 = require("child_process");
const os = require("os");
const path = require("path");
const MODULE_PATH = path.resolve(path.join(__dirname, './telemetryChildProcess.js'));
const SFDX_DISABLE_INSIGHTS = 'SFDX_DISABLE_INSIGHTS';
core_1.Messages.importMessagesDirectory(__dirname);
class TelemetryReporter extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.options = options;
    }
    async init() {
        this.logger = await core_1.Logger.child('TelemetryReporter');
        this.env = this.options.env || new kit_1.Env();
        this.createAppInsightsClient();
    }
    /**
     * Publishes event to app insights dashboard
     * @param eventName {string} - name of the event you want published. Will be concatenated with this.options.project
     * @param attributes {Attributes} - map of properties to publish alongside the event.
     */
    sendTelemetryEvent(eventName, attributes = {}) {
        if (!isSfdxTelemetryEnabled(this.env))
            return;
        if (this.appInsightsClient) {
            const name = `${this.options.project}/${eventName}`;
            const { properties, measurements } = buildPropertiesAndMeasurements(attributes);
            this.logger.debug(`Sending telemetry event: ${name}`);
            try {
                this.appInsightsClient.trackEvent({ name, properties, measurements });
                this.appInsightsClient.flush();
            }
            catch (e) {
                const messages = core_1.Messages.loadMessages('@salesforce/telemetry', 'telemetry');
                throw new core_1.SfdxError(messages.getMessage('unknownError'), 'unknownError', undefined, undefined, e);
            }
        }
        else {
            this.logger.warn('Failed to send telemetry event because the appInsightsClient does not exist');
            throw core_1.SfdxError.create('@salesforce/telemetry', 'telemetry', 'sendFailed');
        }
    }
    /**
     * Initiates the app insights client
     */
    createAppInsightsClient() {
        logTelemetryStatus(this.env, this.logger);
        if (!isSfdxTelemetryEnabled(this.env))
            return;
        this.logger.debug('creating appInsightsClient');
        appInsights
            .setup(this.options.key)
            .setAutoCollectRequests(false)
            .setAutoCollectPerformance(false)
            .setAutoCollectExceptions(false)
            .setAutoCollectDependencies(false)
            .setAutoDependencyCorrelation(false)
            .setAutoCollectConsole(false)
            .setUseDiskRetryCaching(false)
            .setInternalLogging(false, false)
            .start();
        this.appInsightsClient = appInsights.defaultClient;
        this.appInsightsClient.commonProperties = this.buildCommonProperties();
        this.appInsightsClient.context.tags = this.buildContextTags();
        if (isAsimovKey(this.options.key)) {
            this.appInsightsClient.config.endpointUrl = TelemetryReporter.ASIMOV_ENDPOINT;
        }
    }
    /**
     * Builds the properties to send with every event
     * @return {Properties} map of base properites and properties provided when class was created
     */
    buildCommonProperties() {
        const baseProperties = {
            'common.cpus': getCpus(),
            'common.os': os.platform(),
            'common.platformversion': getPlatformVersion(),
            'common.systemmemory': getSystemMemory(),
            'common.usertype': this.env.getString('SFDX_USER_TYPE') || 'normal'
        };
        return Object.assign(baseProperties, this.options.commonProperties);
    }
    /**
     * Builds the context tags for appInsightsClient
     * @return {Properties} map of tags to add to this.appInsightsClient.context.tags
     */
    buildContextTags() {
        const currentTags = this.appInsightsClient ? this.appInsightsClient.context.tags : {};
        return Object.assign({}, currentTags, this.options.contextTags);
    }
}
TelemetryReporter.ASIMOV_ENDPOINT = 'https://vortex.data.microsoft.com/collect/v1';
exports.TelemetryReporter = TelemetryReporter;
class SpawnedTelemetryReporter extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.modulePath = MODULE_PATH;
        this.options = options;
    }
    async init() {
        this.logger = await core_1.Logger.child('SpawnedTelemetry');
        this.env = this.options.env || new kit_1.Env();
        this.beginLifecycle();
    }
    /**
     * Initializes the module at this.modulePath in a child process.
     */
    start() {
        this.logger.debug('starting child process');
        const args = JSON.stringify(this.options);
        this.forkedProcess = child_process_1.fork(this.modulePath, [args]);
        this.logger.debug(`child process started at PID: ${this.forkedProcess.pid}`);
    }
    /**
     * Immediately kills the child process.
     */
    stop() {
        this.logger.debug('stopping child process');
        this.forkedProcess.kill();
    }
    /**
     * Sends message to child process.
     * @param eventName {string} - name of the event you want published.
     * @param attributes {Attributes} - map of properties to publish alongside the event.
     */
    sendTelemetryEvent(eventName, attributes = {}) {
        if (this.forkedProcess) {
            this.forkedProcess.send({ eventName, attributes });
        }
    }
    /**
     * Starts the child process, waits, and then stops the child process.
     */
    beginLifecycle() {
        logTelemetryStatus(this.env, this.logger);
        if (!isSfdxTelemetryEnabled(this.env))
            return;
        this.start();
        const insightsTimeout = Number(this.env.getString(SpawnedTelemetryReporter.SFDX_INSIGHTS_TIMEOUT)) || 3000;
        this.logger.debug(`Waiting ${insightsTimeout} ms to stop child process`);
        setTimeout(() => {
            this.stop();
            this.logger.debug('Stopped child process');
        }, insightsTimeout);
    }
}
SpawnedTelemetryReporter.SFDX_INSIGHTS_TIMEOUT = 'SFDX_INSIGHTS_TIMEOUT';
exports.SpawnedTelemetryReporter = SpawnedTelemetryReporter;
/**
 * Determine if the telemetry event should be logged.
 * Setting SFDX_DISABLE_INSIGHTS to true will disable insights for errors and diagnostics.
 */
function isSfdxTelemetryEnabled(env) {
    const sfdxDisableInsights = env.getBoolean(SFDX_DISABLE_INSIGHTS);
    const isEnabled = !sfdxDisableInsights;
    return isEnabled;
}
function logTelemetryStatus(env, logger) {
    const isEnabled = isSfdxTelemetryEnabled(env);
    logger.debug(`'${SFDX_DISABLE_INSIGHTS}': ${!isEnabled}`);
    if (isEnabled) {
        logger.warn(`Insights logging in enabled. This can be disabled by setting ${SFDX_DISABLE_INSIGHTS}=true`);
    }
    else {
        logger.warn(`Insights logging in disabled. This can be enabled by setting ${SFDX_DISABLE_INSIGHTS}=false`);
    }
}
function buildPropertiesAndMeasurements(attributes) {
    const properties = {};
    const measurements = {};
    Object.keys(attributes).forEach(key => {
        const value = attributes[key];
        if (typeof value === 'string') {
            properties[key] = value;
        }
        else if (typeof value === 'number') {
            measurements[key] = value;
        }
    });
    return { properties, measurements };
}
exports.buildPropertiesAndMeasurements = buildPropertiesAndMeasurements;
function getPlatformVersion() {
    return (os.release() || '').replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, '$1$2$3');
}
exports.getPlatformVersion = getPlatformVersion;
function getCpus() {
    const cpus = os.cpus();
    if (cpus && cpus.length > 0) {
        return `${cpus[0].model}(${cpus.length} x ${cpus[0].speed})`;
    }
    else {
        return '';
    }
}
exports.getCpus = getCpus;
function getSystemMemory() {
    return `${(os.totalmem() / (1024 * 1024 * 1024)).toFixed(2)} GB`;
}
function isAsimovKey(key) {
    return !!(key && key.indexOf('AIF-') === 0);
}
//# sourceMappingURL=telemetryReporter.js.map