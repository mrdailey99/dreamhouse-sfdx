"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const telemetry_1 = require("@salesforce/telemetry");
const ts_types_1 = require("@salesforce/ts-types");
const cp = require("child_process");
const Debug = require("debug");
const fsx = require("fs-extra");
const path = require("path");
const analytics_1 = require("../analytics");
const PROJECT = 'sfdx-plugin-analytics';
const APP_INSIGHTS_KEY = '2ca64abb-6123-4c7b-bd9e-4fe73e71fe9c';
const debug = Debug('sfdx:analytics');
const USAGE_ACKNOWLEDGEMENT_FILE_NAME = 'acknowledgedUsageCollection.json';
const USAGE_FILE_NAME = 'sfdx-usage.json';
const DAY_IN_MILLIS = 1000 * 60 * 60 * 24;
// tslint:disable-next-line:variable-name
exports.GdprDefaultLabel = '<GDPR_HIDDEN>';
function debugErrMsg(err) {
    return err.stack || err.message || err;
}
async function acknowledgeDataCollection(hookContext) {
    const acknowledgementFilePath = path.join(hookContext.config.cacheDir, USAGE_ACKNOWLEDGEMENT_FILE_NAME);
    try {
        await core_1.fs.access(acknowledgementFilePath, fsx.constants.R_OK);
        debug('Usage acknowledgement file already exists');
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            hookContext.warn('You acknowledge and agree that the CLI tool may collect usage information, ' +
                'user environment, and crash reports for the purposes of providing services or functions that are relevant ' +
                'to use of the CLI tool and product improvements.');
            // outputJSON will create any missing directories in the file path
            await fsx.outputJSON(acknowledgementFilePath, { acknowledged: true });
            debug('Wrote usage acknowledgement file', acknowledgementFilePath);
        }
        else {
            debug('Could not access', acknowledgementFilePath, 'DUE TO:', debugErrMsg(err));
        }
    }
}
exports.acknowledgeDataCollection = acknowledgeDataCollection;
// Determines whether the SFDX project is using GIT for version control or some other VCS.
// Returns a token indicating the VCS for usage stats, or an empty string if the command
// was executed outside of an SFDX project.
exports.getVCSInfo = async () => {
    try {
        const projectPath = await core_1.SfdxProject.resolveProjectPath();
        const gitPath = path.join(projectPath, '.git');
        try {
            await core_1.fs.access(gitPath, fsx.constants.R_OK);
            return 'vcs:git';
        }
        catch (err) {
            return 'vcs:other';
        }
    }
    catch (err) {
        return '';
    }
};
// Reads from analytics.json to get all command usage data and calculates minimum, maximum,
// and average runtime as well as total executions and errors for each command.
async function calcUsage(hookContext, devhubOrg, startOfDay) {
    const usages = {};
    const hubOrgId = devhubOrg.getOrgId();
    const analyticsCommand = new analytics_1.default(hookContext.config);
    let commands;
    try {
        const analyticsJson = await analyticsCommand.readJSON();
        commands = analyticsJson.commands;
    }
    catch (err) {
        debug('Could not read from analytics file:', analyticsCommand.analyticsPath, 'so no command usage can be sent.', debugErrMsg(err));
        return usages;
    }
    debug('Calculating command usage from', analyticsCommand.analyticsPath, 'for', commands.length, 'commands');
    const vcsInfo = await exports.getVCSInfo();
    commands.forEach(command => {
        let version = `${command.version}`;
        if (command.plugin_version) {
            version = `${version} ${command.plugin_version}`;
        }
        const commandKey = `${command.command}-${version}`;
        const runtime = command.runtime;
        const month = (startOfDay.getMonth() + 1).toString().padStart(2, '0');
        const day = startOfDay.getDate().toString().padStart(2, '0');
        const usage = usages[commandKey] || {
            commandName: command.command,
            toolbeltVersion: `${hookContext.config.version} ${command.plugin_version} ${vcsInfo}`,
            hubOrgId,
            usageDate: `${startOfDay.getFullYear()}${month}${day}`,
            totalExecutions: 0,
            totalErrors: 0,
            avgRuntime: 0,
            minRuntime: runtime,
            maxRuntime: runtime
        };
        if (command.status !== 0) {
            usage.totalErrors++;
        }
        // Run an accumalative average, which is ((avg * totalExecution) + newTime) / (totalExecutions + 1)
        usage.avgRuntime = Math.round((runtime + (usage.avgRuntime * (usage.totalExecutions))) / (usage.totalExecutions + 1));
        usage.totalExecutions++;
        // update minRuntime and maxRuntime
        if (runtime > usage.maxRuntime) {
            usage.maxRuntime = runtime;
        }
        else if (runtime < usage.minRuntime) {
            usage.minRuntime = runtime;
        }
        usages[commandKey] = usage;
    });
    return usages;
}
exports.calcUsage = calcUsage;
// Sends the command analytics data to the server.
async function logOnServer(logType, usages) {
    const reporter = await telemetry_1.default.create({ project: PROJECT, key: APP_INSIGHTS_KEY });
    try {
        usages.forEach((usage) => reporter.sendTelemetryEvent(logType, usage));
    }
    catch (err) {
        debug('Failed to log command analytics to the server due to:', debugErrMsg(err));
    }
}
exports.logOnServer = logOnServer;
// If more than a day has passed since a command has run, log all command analytics
// to the server, clear the analytics.log file, and update the timestamp in sfdx-usage.json.
// Writes the sfdx-usage.json file if it doesn't yet exist.
async function logUsage(hookContext) {
    const now = new Date();
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    // Get timestamp in seconds, at the start of the day.
    const timestamp = startOfDay.getTime();
    const usageFilePath = path.join(hookContext.config.cacheDir, USAGE_FILE_NAME);
    const writeUsageFile = async () => {
        debug('Writing/updating sfdx usage file', USAGE_FILE_NAME, 'with timestamp for date:', startOfDay.toISOString());
        return core_1.fs.writeJson(usageFilePath, { startTime: timestamp });
    };
    // Read the usage file for the timestamp.  Write the file if it doesn't yet exist.
    let usageTime = timestamp;
    try {
        debug('Reading sfdx usage file', USAGE_FILE_NAME);
        const lastUsage = await core_1.fs.readJsonMap(usageFilePath);
        usageTime = ts_types_1.ensureNumber(lastUsage.startTime);
    }
    catch (err) {
        // If sfdx-usage.json doesn't exist write it.  Ignore all other errors.
        if (err.code === 'ENOENT') {
            await writeUsageFile();
        }
        else {
            debug('Error reading', USAGE_FILE_NAME, 'due to:', debugErrMsg(err));
        }
    }
    // If it has been past 24 hours, then calculate and log usage for the previous day,
    // clear the analytics log, and write a new timestamp for sfdx-analytics.json.
    if (now.getTime() - usageTime >= DAY_IN_MILLIS) {
        debug('More than a day has passed so calc and send usage data');
        try {
            const devhubOrg = await core_1.Org.create({ isDevHub: true });
            const usages = await calcUsage(hookContext, devhubOrg, startOfDay);
            const usageValues = ts_types_1.definiteValuesOf(usages);
            if (usageValues.length > 0) {
                await logOnServer('DIAGNOSTIC', usageValues);
            }
            const analyticsCommand = new analytics_1.default(hookContext.config);
            debug('Clearing usage data in', analyticsCommand.analyticsPath);
            await analyticsCommand.clear();
            await writeUsageFile();
        }
        catch (err) {
            debug('Error gathering and sending usage data due to:', debugErrMsg(err));
        }
    }
}
exports.logUsage = logUsage;
// Writes command usage stats to analytics.log in the CLI cache dir.
async function writeUsage(hookContext, options) {
    try {
        const start = Date.now();
        const command = options.Command;
        const commandFlags = command.flags || {};
        const validFlags = Object.keys(commandFlags).reduce((result, flag) => {
            const shortFlag = commandFlags[flag].char ? commandFlags[flag].char : null;
            return shortFlag ? result.concat([shortFlag, flag]) : result.concat(flag);
        }, []);
        // Only log usage for commands with plugins
        if (command && command.plugin) {
            debug('setting up exit handler');
            // NOTE: All calls within the exit callback must be synchronous.
            process.on('exit', status => {
                const logFile = path.join(hookContext.config.cacheDir, 'analytics.log');
                debug('using', logFile, 'for usage error logging');
                const fd = fsx.openSync(logFile, 'a');
                const { cacheDir, platform, shell, version } = hookContext.config;
                cp.spawn(process.argv[0], [
                    path.join(__dirname, '../processes/logUsage'),
                    JSON.stringify({
                        config: { cacheDir, platform, shell, version },
                        plugin: command.plugin ? { name: command.plugin.name, version: command.plugin.version } : undefined,
                        commandId: command.id,
                        time: Date.now() - start,
                        status
                    })
                ], {
                    detached: !hookContext.config.windows,
                    stdio: ['ignore', fd, fd]
                }).unref();
                debug('spawned usage "', process.argv[0], path.join(__dirname, '../processes/logUsage'), '"');
            });
            // Log command errors to the server.  The ts-ignore is necessary
            // because TS is strict about the events that can be handled on process.
            // @ts-ignore
            process.on('cmdError', async (cmdErr, flags = {}, org) => {
                try {
                    const pluginVersion = ts_types_1.getString(command, 'plugin.version', '');
                    org = org || await core_1.Org.create({ isDevHub: true });
                    // We can't log anything without an org.
                    if (!org) {
                        throw (Error('NoOrgFound'));
                    }
                    const hubOrg = await org.getDevHubOrg();
                    let orgType = await org.determineIfDevHubOrg() && 'devhub';
                    if (!orgType) {
                        try {
                            await org.checkScratchOrg(hubOrg && hubOrg.getUsername());
                            orgType = 'scratch';
                        }
                        catch (err) {
                            orgType = 'unknown';
                        }
                    }
                    const commandParams = Object.keys(flags).filter(arg => validFlags.includes(arg)).join(',');
                    const errorLogRecord = {
                        commandName: command.id,
                        commandParams,
                        commandTimestamp: start,
                        hubOrgId: hubOrg ? hubOrg.getOrgId() : '',
                        toolbeltVersion: `${hookContext.config.version} ${pluginVersion}`,
                        sourceApiVersion: org.getConnection().getApiVersion(),
                        origin: hookContext.config.userAgent,
                        artifactName: exports.GdprDefaultLabel,
                        orgType,
                        errorName: cmdErr.name,
                        errorMessage: exports.GdprDefaultLabel,
                        errorStack: exports.GdprDefaultLabel,
                        // @ts-ignore
                        __errorWhitelist__: cmdErr.errWhitelist
                    };
                    debug('Sending cmd error log:', errorLogRecord);
                    await logOnServer('ERROR', [errorLogRecord]);
                }
                catch (err) {
                    debug('Could not send command error to server due to:', debugErrMsg(err));
                }
            });
        }
        else {
            debug('no plugin found for analytics');
        }
    }
    catch (err) {
        debug('error tracking usage:', debugErrMsg(err));
    }
}
exports.writeUsage = writeUsage;
/**
 * A hook that runs before every command that:
 *   1. Warns the user about command usage data collection the CLI does
 *      unless they have already acknowledged the warning.
 *   2. Logs command usage data to the server if more than 24 hours has passed
 *      since the last command execution.
 *   3. Writes command execution stats to a file after command has finished running.
 */
const hook = async function (options) {
    await acknowledgeDataCollection(this);
    await logUsage(this);
    await writeUsage(this, options);
};
exports.default = hook;
//# sourceMappingURL=analyticsPrerun.js.map