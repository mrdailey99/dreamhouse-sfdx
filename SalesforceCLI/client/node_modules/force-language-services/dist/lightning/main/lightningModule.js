"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lightningGenerator_1 = require("./lightningGenerator");
const lightningCmpGenerator_1 = require("../../lightningcmp/main/lightningCmpGenerator");
const lightningControllerGenerator_1 = require("../../lightningcontroller/main/lightningControllerGenerator");
const lightningHelperGenerator_1 = require("../../lightninghelper/main/lightningHelperGenerator");
const lightningCssGenerator_1 = require("../../lightningcss/main/lightningCssGenerator");
const lightningRendererGenerator_1 = require("../../lightningrenderer/main/lightningRendererGenerator");
const lightningDesignGenerator_1 = require("../../lightningdesign/main/lightningDesignGenerator");
const lightningSVGGenerator_1 = require("../../lightningsvg/main/lightningSVGGenerator");
const lightningDocumentationGenerator_1 = require("../../lightningdocumentation/main/lightningDocumentationGenerator");
const lightningAppGenerator_1 = require("../../lightningapp/main/lightningAppGenerator");
const lightningEvtGenerator_1 = require("../../lightningevt/main/lightningEvtGenerator");
const lightningIntfGenerator_1 = require("../../lightningintf/main/lightningIntfGenerator");
const lightningLwcGenerator_1 = require("../../lightninglwc/main/lightningLwcGenerator");
const createBase_1 = require("../../common/main/createBase");
const generatorUtil_1 = require("../../common/main/generatorUtil");
const commandUtil_1 = require("../../common/main/commandUtil");
const lightningTypesInfo_1 = require("../../lightning/main/lightningTypesInfo");
const lightningTypes_1 = require("../../lightning/main/lightningTypes");
const Messages = require("../../common/main/Messages");
class LightningModule {
    /**
     * @param {bundleName} - name of the new lightning bundle
     * @param {targetPath} - where to generate the bundle
     * @param (options) - available options (to be documented)
     *     should allow config - which is a json file with all the options in a decision tree form)
     */
    create(bundleName, targetPath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const generatorName = 'force:lightning';
            let addGenerators = function (env) {
                env.registerStub(lightningGenerator_1.LightningGenerator, generatorName);
                env.registerStub(lightningCmpGenerator_1.LightningCmpGenerator, 'force:lightningcmp');
                env.registerStub(lightningLwcGenerator_1.LightningLwcGenerator, 'force:lightningwebcomponent');
                env.registerStub(lightningAppGenerator_1.LightningAppGenerator, 'force:lightningapp');
                env.registerStub(lightningEvtGenerator_1.LightningEventGenerator, 'force:lightningevt');
                env.registerStub(lightningIntfGenerator_1.LightningInterfaceGenerator, 'force:lightningintf');
                env.registerStub(lightningControllerGenerator_1.LightningControllerGenerator, 'force:lightningcontroller');
                env.registerStub(lightningHelperGenerator_1.LightningHelperGenerator, 'force:lightninghelper');
                env.registerStub(lightningCssGenerator_1.LightningCssGenerator, 'force:lightningcss');
                env.registerStub(lightningRendererGenerator_1.LightningRendererGenerator, 'force:lightningrenderer');
                env.registerStub(lightningDesignGenerator_1.LightningDesignGenerator, 'force:lightningdesign');
                env.registerStub(lightningSVGGenerator_1.LightningSVGGenerator, 'force:lightningsvg');
                env.registerStub(lightningDocumentationGenerator_1.LightningDocumentationGenerator, 'force:lightningdocumentation');
            };
            let checkInputs = function () {
                const checkNameResult = generatorUtil_1.GeneratorUtil.checkName(bundleName);
                if (checkNameResult.length > 0) {
                    return checkNameResult;
                }
                let bundleType = options['bundleType'];
                if (!bundleType || lightningTypes_1.LightningTypesUtil.lightningChoices.indexOf(bundleType) === -1) {
                    return 'invalid bundle type - ' + bundleType;
                }
                const genInfo = lightningTypesInfo_1.LightningTypesInfo.getInfo(bundleType);
                const templateName = options['template'];
                if (templateName && genInfo) {
                    if (!genInfo.isValidTemplate(templateName)) {
                        return Messages.get('InvalidTemplate');
                    }
                }
                const apiVersion = options['apiVersion'];
                if (apiVersion && genInfo) {
                    if (!genInfo.isValidApiVersion(apiVersion)) {
                        return Messages.get('InvalidApiVersion');
                    }
                }
                /**
                 * Aura bundles must have a directory named aura (all lowercase)
                 * in its path. The exception to this would be when the internal option
                 * is set.
                 *
                 * LWC bundles must have a directory named lwc
                 * (all lowercase) in its path. The exception to this would be when
                 * the internal option is set.
                 *
                 * The folder can be a direct parent or anywhere
                 * higher up in the tree. This check does not enforce the target
                 * path to be an SFDX workspace because there's nothing in
                 * lightning create that requires it.
                 */
                const internal = options['internal'];
                if (typeof internal === undefined || !internal) {
                    if (bundleType === lightningTypes_1.LightningBundles[lightningTypes_1.LightningBundles.lightningwebcomponent].toString()) {
                        if (!generatorUtil_1.GeneratorUtil.isFolderInPath('lwc', targetPath)) {
                            return Messages.get('InvalidLwcBundlePath');
                        }
                    }
                    else {
                        if (!generatorUtil_1.GeneratorUtil.isFolderInPath('aura', targetPath)) {
                            return Messages.get('InvalidAuraBundlePath');
                        }
                    }
                }
                return '';
            };
            const createOptions = options;
            if (lightningTypes_1.LightningTypesUtil.getCmdName(lightningTypes_1.LightningTypesUtil.getBundle(options['bundleType'])) === 'component'
                && options['type'] === lightningTypes_1.LightningTypes.lwc) {
                createOptions['bundleType'] = 'lightningwebcomponent';
            }
            createOptions['bundleName'] = bundleName;
            let rawOutput = yield new createBase_1.CreateBase().create(bundleName, targetPath, createOptions, generatorName, checkInputs, addGenerators);
            if (options['json']) {
                return generatorUtil_1.GeneratorUtil.jsonOutput(rawOutput);
            }
            else {
                return rawOutput;
            }
        });
    }
    static getNameFlagName(bundleType) {
        return lightningTypes_1.LightningTypesUtil.getCmdName(lightningTypes_1.LightningTypesUtil.getBundle(bundleType)) + commandUtil_1.CommandUtil.NAME_FLAG;
    }
    static getPathFlagName() {
        return commandUtil_1.CommandUtil.PATH_FLAG;
    }
    static getFlagMap() {
        let flagMap = new Map();
        flagMap.set(LightningModule.LIGHTNING_TYPE_FLAG, LightningModule.LIGHTNING_TYPE_OPTION);
        flagMap.set(LightningModule.LIGHTNING_INTERNAL_FLAG, LightningModule.LIGHTNING_INTERNAL_FLAG);
        return flagMap;
    }
    static reflectCreate(bundleType) {
        let reflect = { flags: {} };
        if (bundleType && lightningTypes_1.LightningTypesUtil.lightningChoices.indexOf(bundleType) === -1) {
            return reflect;
        }
        generatorUtil_1.GeneratorUtil.addNameFlag(reflect, LightningModule.getNameFlagName(bundleType), Messages.get('LightningNameFlagDescription', lightningTypes_1.LightningTypesUtil.getCmdName(lightningTypes_1.LightningTypesUtil.getBundle(bundleType))), Messages.get('LightningNameFlagLongDescription', lightningTypes_1.LightningTypesUtil.getCmdName(lightningTypes_1.LightningTypesUtil.getBundle(bundleType))));
        const genInfo = lightningTypesInfo_1.LightningTypesInfo.getInfo(bundleType);
        if (!genInfo) {
            // this shouldnt be possible since bundleType is checked, but TypeScript cant figure that out
            return reflect;
        }
        generatorUtil_1.GeneratorUtil.addCommonFlags(reflect, genInfo);
        generatorUtil_1.GeneratorUtil.addApiVersionFlag(reflect, genInfo);
        if (lightningTypes_1.LightningTypesUtil.getCmdName(lightningTypes_1.LightningTypesUtil.getBundle(bundleType)) === 'component') {
            generatorUtil_1.GeneratorUtil.addLightningType(reflect, genInfo);
        }
        // flag used for internal core scenarios
        generatorUtil_1.GeneratorUtil.addFlag(reflect, {
            name: LightningModule.LIGHTNING_INTERNAL_FLAG,
            char: 'x',
            hasValue: false,
            required: false,
            hidden: true,
            description: Messages.get('LightningInternalFlagDescription'),
            longDescription: Messages.get('LightningInternalFlagLongDescription')
        }, [], '');
        return reflect;
    }
}
LightningModule.LIGHTNING_TYPE_FLAG = 'type';
LightningModule.LIGHTNING_TYPE_OPTION = 'type';
LightningModule.LIGHTNING_INTERNAL_FLAG = 'internal';
exports.LightningModule = LightningModule;
;

//# sourceMappingURL=lightningModule.js.map
