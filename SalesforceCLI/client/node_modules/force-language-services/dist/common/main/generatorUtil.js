"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const Messages = require("../../common/main/Messages");
const commandUtil_1 = require("../../common/main/commandUtil");
const lightningTypes_1 = require("../../lightning/main/lightningTypes");
class GeneratorUtil {
    static getTemplateDir(generatorDir) {
        return path.join(generatorDir, '../templates');
    }
    static setPaths(generatorDir, gen, options) {
        gen.sourceRoot(GeneratorUtil.getTemplateDir(generatorDir));
        let targetPath = options['targetPath'];
        if (targetPath) {
            gen.destinationRoot(targetPath);
        }
    }
    static normalizeOptions(inputOpts) {
        // assume simple object for config for starting, then adapt for file (fs.readfile,etc)
        let configOpt = inputOpts['config'];
        if (configOpt) {
            let config = JSON.parse(configOpt);
            // add in the other options
            for (let name in inputOpts) {
                if (name !== 'config') {
                    config[name] = inputOpts[name];
                }
            }
            return config;
        }
        else {
            return inputOpts;
        }
    }
    /**
     * The name can only contain characters, letters, and the underscore character
     * It must start with a letter, cannot end with an underscore or contain 2 consecutive underscores
     *
     * See the method isValidDeveloperName in
     * https://git.soma.salesforce.com/forcedotcommons/commons-text/blob/master/src/main/java/com/force/commons/text/TextUtil.java
     *
     * inputName is known to be not empty
     * return an empty string if the name is valid, otherwise the proper error message
     */
    static checkForInvalidName(inputName) {
        const alphaRegExp = /^\w+$/;
        if (!alphaRegExp.test(inputName)) {
            return Messages.get('AlphaNumericNameError');
        }
        const letterStartRegExp = /^[A-Za-z]/;
        if (!letterStartRegExp.test(inputName)) {
            return Messages.get('NameMustStartWithLetterError');
        }
        const endUnderscore = /_$/;
        if (endUnderscore.test(inputName)) {
            return Messages.get('EndWithUnderscoreError');
        }
        const dblUnderscore = /__/;
        if (dblUnderscore.test(inputName)) {
            return Messages.get('DoubleUnderscoreError');
        }
        return '';
    }
    static checkName(name) {
        if (!name) {
            return Messages.get('MissingName');
        }
        else {
            let nameError = GeneratorUtil.checkForInvalidName(name);
            if (nameError) {
                return nameError;
            }
            else {
                return '';
            }
        }
    }
    // check for a targetDir with forward slashs
    // if that fails (Windows) then check for backward slashes
    static getTargetDir(rawOutput) {
        let targetDirExp = new RegExp('target dir = (.*' + path.sep + '.*)', 'mig');
        let result = targetDirExp.exec(rawOutput);
        if (result) {
            return result[1];
        }
        return '';
    }
    static getCreatedFiles(rawOutput) {
        let createdFiles = [];
        let createExp = new RegExp('(\\n\\s+)(create\\s+\|identical\\s+\|force\\s+)(.*)', 'mig');
        // unrolled loop required due to tslint rule on not doing assignments in conditionals
        // exec must be repeated to get all the matches
        // rawOutput.match will give all matches, but not the capture groups (the desired data)
        let result = createExp.exec(rawOutput);
        while (result) {
            createdFiles.push(result[3]);
            result = createExp.exec(rawOutput);
        }
        return createdFiles;
    }
    static jsonOutput(rawOutput) {
        let output = {
            outputDir: GeneratorUtil.getTargetDir(rawOutput),
            created: GeneratorUtil.getCreatedFiles(rawOutput),
            rawOutput
        };
        return JSON.stringify(output);
    }
    static addFlag(reflect, flag, values, defaultValue) {
        reflect.flags[flag.name] = { commandFlagInfo: flag, values: values };
        if (defaultValue) {
            reflect.flags[flag.name].default = defaultValue;
        }
    }
    static addNameFlag(reflect, flagName, nameDescription, nameLongDescription) {
        let nameFlag = {
            name: flagName,
            char: 'n',
            hasValue: true,
            required: true,
            description: nameDescription,
            longDescription: nameLongDescription
        };
        GeneratorUtil.addFlag(reflect, nameFlag, []);
    }
    static addApiVersionFlag(reflect, genInfo) {
        let values = genInfo.getApiVersions();
        let defaultValue = genInfo.getDefaultApiVersion();
        GeneratorUtil.addFlag(reflect, {
            name: 'apiversion',
            char: 'a',
            hasValue: true,
            required: false,
            description: Messages.get('ApiVersionFlag'),
            longDescription: Messages.get('ApiVersionFlagLongDescription')
        }, values, defaultValue);
    }
    static addLightningType(reflect, genInfo) {
        const values = [lightningTypes_1.LightningTypes.aura, lightningTypes_1.LightningTypes.lwc];
        const defaultValue = lightningTypes_1.LightningTypes.aura;
        GeneratorUtil.addFlag(reflect, {
            name: 'type',
            hasValue: true,
            required: false,
            description: Messages.get('LightningTypeFlagDescription'),
            longDescription: Messages.get('LightningTypeFlagLongDescription')
        }, values, defaultValue);
    }
    static addCommonFlags(reflect, genInfo, suppressTemplates) {
        GeneratorUtil.addCommonFlags2(reflect, genInfo.getTemplates(), genInfo.getDefaultTemplate());
    }
    static addCommonFlags2(reflect, validTemplates, defaultTemplate, suppressTemplates) {
        let outputDirFlag = {
            name: commandUtil_1.CommandUtil.PATH_FLAG,
            char: 'd',
            hasValue: true,
            required: false,
            description: Messages.get('TargetPathFlag'),
            longDescription: Messages.get('TargetPathLongDescription')
        };
        let jsonFlag = {
            name: commandUtil_1.CommandUtil.JSON_FLAG,
            hasValue: false,
            required: false,
            description: Messages.get('JsonFlag'),
            longDescription: Messages.get('JsonFlagLongDescription')
        };
        let reflectFlag = {
            name: commandUtil_1.CommandUtil.REFLECT_FLAG,
            char: 'r',
            hasValue: false,
            required: false,
            hidden: true,
            description: Messages.get('ReflectionFlag'),
            longDescription: Messages.get('ReflectionFlagLongDescription')
        };
        if (!suppressTemplates) {
            let templateFlag = {
                name: commandUtil_1.CommandUtil.TEMPLATE_FLAG,
                char: 't',
                hasValue: true,
                required: false,
                description: Messages.get('TemplateFlag'),
                longDescription: Messages.get('TemplateFlagLongDescription')
            };
            GeneratorUtil.addFlag(reflect, templateFlag, validTemplates, defaultTemplate);
        }
        GeneratorUtil.addFlag(reflect, outputDirFlag, []);
        GeneratorUtil.addFlag(reflect, jsonFlag, []);
        GeneratorUtil.addFlag(reflect, reflectFlag, []);
    }
    static getTemplates(generatorDir, suffix) {
        let templateDir = GeneratorUtil.getTemplateDir(generatorDir);
        let templateFileNames = fs.readdirSync(templateDir);
        let templateNames = [];
        for (let i = 0; i < templateFileNames.length; i++) {
            if (path.extname(templateFileNames[i]) === suffix) {
                let baseName = path.basename(templateFileNames[i], suffix);
                if (templateFileNames[i].indexOf('Default') !== -1) {
                    templateNames.unshift(baseName);
                }
                else {
                    templateNames.push(baseName);
                }
            }
        }
        return templateNames;
    }
    static getMatchTemplates(generatorDir, match) {
        let templateDir = GeneratorUtil.getTemplateDir(generatorDir);
        let templateFileNames = fs.readdirSync(templateDir);
        let templateNames = [];
        for (let i = 0; i < templateFileNames.length; i++) {
            if (templateFileNames[i].indexOf(match) >= 0) {
                templateNames.push(templateFileNames[i]);
            }
        }
        return templateNames;
    }
    static isValidTemplate(templates, inputTemplate) {
        for (let i = 0; i < templates.length; i++) {
            if (templates[i] === inputTemplate) {
                return true;
            }
        }
        return false;
    }
    // TODO ? should the default be based on the config info of the Project?
    static getValidApiVersionValues(low, high) {
        let values = [];
        for (let i = high; i >= low; i--) {
            values.push(i.toFixed(1));
        }
        return values;
    }
    static isValidApiVersion(inputVersion, low, high) {
        let valid = GeneratorUtil.getValidApiVersionValues(low, high);
        for (let i = 0; i < valid.length; i++) {
            if (inputVersion === valid[i]) {
                return true;
            }
        }
        return false;
    }
    static isFolderInPath(folderName, targetPath) {
        let fullTargetPath = process.cwd();
        if (targetPath) {
            fullTargetPath = path.resolve(targetPath);
        }
        let folders = fullTargetPath.split(path.sep);
        return folders.some(folder => folder === folderName);
    }
}
GeneratorUtil.NAME_OPTION = 'name';
GeneratorUtil.TEMPLATE_OPTION = 'template';
GeneratorUtil.REFLECT_OPTION = 'reflect';
GeneratorUtil.PATH_OPTION = 'targetPath';
GeneratorUtil.JSON_OPTION = 'json';
GeneratorUtil.CONFIG_OPTION = 'config';
GeneratorUtil.API_VERSION_OPTION = 'apiVersion';
exports.GeneratorUtil = GeneratorUtil;

//# sourceMappingURL=generatorUtil.js.map
