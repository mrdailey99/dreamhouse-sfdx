"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Messages = require("../../common/main/Messages");
const generatorUtil_1 = require("./generatorUtil");
class CommandUtil {
    static getCommonFlagMap() {
        let flagMap = new Map();
        flagMap.set(CommandUtil.API_VERSION_FLAG, generatorUtil_1.GeneratorUtil.API_VERSION_OPTION);
        flagMap.set(CommandUtil.CONFIG_FLAG, generatorUtil_1.GeneratorUtil.CONFIG_OPTION);
        flagMap.set(CommandUtil.JSON_FLAG, generatorUtil_1.GeneratorUtil.JSON_OPTION);
        flagMap.set(CommandUtil.TEMPLATE_FLAG, generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION);
        flagMap.set(CommandUtil.PATH_FLAG, generatorUtil_1.GeneratorUtil.PATH_OPTION);
        return flagMap;
    }
}
CommandUtil.API_VERSION_FLAG = 'apiversion';
CommandUtil.CONFIG_FLAG = 'config';
CommandUtil.JSON_FLAG = 'json';
CommandUtil.TEMPLATE_FLAG = 'template';
CommandUtil.PATH_FLAG = 'outputdir';
CommandUtil.NAME_FLAG = 'name';
CommandUtil.REFLECT_FLAG = 'reflect';
exports.CommandUtil = CommandUtil;
exports.translateContextFlagsToOptions = function (commandContext, options, flagMap) {
    // HerokuContext should always have a flags element, but check as a precondition
    if (!commandContext.flags) {
        throw new ReferenceError(Messages.get('MissingFlags'));
    }
    let commonFlagMap = CommandUtil.getCommonFlagMap();
    commonFlagMap.forEach((value, key) => {
        if (commandContext.flags[key]) {
            options[value] = commandContext.flags[key];
        }
    });
    if (flagMap) {
        flagMap.forEach((value, key) => {
            if (commandContext.flags[key]) {
                options[value] = commandContext.flags[key];
            }
        });
    }
};

//# sourceMappingURL=commandUtil.js.map
