"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
/**
 * An {@link SfdxCommand} adapter that delegates configuration and execution to legacy command declarations.
 */
class LegacyCommand extends command_1.SfdxCommand {
    /**
     * Convert legacy-style flag declarations to SfdxCommand's updated format.
     *
     * @param {Optional<Flag[]>} flags The legacy flags to convert.
     * @returns {FlagsConfig}
     */
    static toFlagsConfig(flags) {
        const flagsConfig = {};
        if (flags) {
            flags.forEach(flag => {
                const { name, char, hidden, required, longDescription, type, values, array } = flag;
                const description = ts_types_1.ensure(flag.description);
                const config = {
                    description,
                    longDescription,
                    hidden,
                    required,
                    default: flag.default
                };
                if (char) {
                    // oclif types char as a single alpha char, but Flag specifies it as `string`,
                    // so we use `any` here to get tsc to accept the assignment
                    config.char = char;
                }
                if (values && values.length > 0) {
                    config.options = values;
                }
                const { hasValue } = flag;
                delete flag.hasValue;
                if (name === 'apiversion') {
                    // backdoor for forcibly setting `char` on the config; this is disallowed by the
                    // sfdx flags typings, as its discouraged, but in this case we need to do it for
                    // backward compatibility
                    kit_1.set(config, 'char', char);
                    flagsConfig.apiversion = command_1.flags.builtin(config);
                }
                else {
                    if (type && ts_types_1.isKeyOf(command_1.flags, type)) {
                        if (!hasValue || type === 'boolean') {
                            flagsConfig[name] = command_1.flags.boolean(config);
                        }
                        else if (array) {
                            if (config.options) {
                                config.description += ` (${config.options.join('|')})`;
                                delete config.options;
                            }
                            flagsConfig[name] = command_1.flags.array(config);
                        }
                        else if (type === 'string') {
                            flagsConfig[name] = command_1.flags.string(config);
                        }
                        else {
                            // TODO
                            throw new Error('Unrecognized flag: ' + JSON.stringify(flag));
                        }
                    }
                    else {
                        // TODO
                        throw new Error('Unrecognized flag: ' + JSON.stringify(flag));
                    }
                }
            });
        }
        return flagsConfig;
    }
    /**
     * Delegates command execution to the legacy command declaration.
     */
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.runLegacy(yield this.resolveHerokuContext());
            if (!this.flags.json) {
                this.ux.log(results);
            }
            else {
                return JSON.parse(results);
            }
            return {};
        });
    }
    /**
     * Converts the current command instance and config into a legacy-compatible context.
     */
    resolveHerokuContext() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stringifyFlags();
            return {
                flags: this.flags
            };
        });
    }
    /**
     * Call to stringify parsed flags for backward compatibility.
     */
    stringifyFlags() {
        Object.keys(this.flags).forEach(name => {
            const flag = this.flags[name];
            if (flag == null) {
                return;
            }
            const isUserSupplied = process.argv.find(arg => {
                const char = this.ctor && this.ctor.flags && this.ctor.flags[name] && this.ctor.flags[name].char;
                // The value can be in the same argv with = or by itself
                return new RegExp(`^--${name}(=.+)?$`).test(arg) || new RegExp(`^-${char}(=.+)?$`).test(arg);
            });
            if (!isUserSupplied) {
                delete this.flags[name];
                return;
            }
            ;
            switch (typeof this.flags[name]) {
                case 'string':
                case 'number':
                    this.flags[name] = flag + '';
                    break;
                case 'boolean':
                    break;
                case 'object':
                    if (Array.isArray(flag)) {
                        this.flags[name] = flag.join(',');
                        break;
                    }
                    else if (flag instanceof Date) {
                        this.flags[name] = flag.toISOString();
                        break;
                    }
                    else if (flag instanceof kit_1.Duration) {
                        this.flags[name] = flag.quantity + '';
                        break;
                    }
                    else {
                        throw new core_1.SfdxError(`Unexpected value type for flag ${name}`, 'UnexpectedFlagValueType');
                    }
                    break;
                default:
                    throw new core_1.SfdxError(`Unexpected value type for flag ${name}`, 'UnexpectedFlagValueType');
            }
        });
    }
}
exports.LegacyCommand = LegacyCommand;

//# sourceMappingURL=LegacyCommand.js.map
