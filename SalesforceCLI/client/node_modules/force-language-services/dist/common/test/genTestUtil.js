"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
const fs = require("fs");
const fse = require("fs-extra"); //TODO ? use only fs-extra?
const path = require("path");
class GenTestUtil {
    static checkFile(expectedString, fileName) {
        let fsOpts = { flag: 'r', encoding: 'utf8' };
        let testExpr = new RegExp(expectedString);
        let data = fs.readFileSync(fileName, fsOpts);
        //if (err) throw (err);
        let res = '';
        data.toString().split(/\n/).forEach(function (line) {
            if (!testExpr.test(line)) {
                return;
            }
            res += line + '\n';
        });
        if (res.length > 0) {
            return true;
        }
        else {
            return false;
        }
    }
    static checkNameAndVersion(name, targetPath, apiVersion, fileName) {
        let fullFilePath = GenTestUtil.fullPath(targetPath, fileName);
        chai.expect(GenTestUtil.checkFile('fqn="' + name + '"', fullFilePath)).true;
        chai.expect(GenTestUtil.checkFile('<apiVersion>' + apiVersion + '</apiVersion>', fullFilePath)).true;
    }
    static checkCreateOutput(output, targetPath, outFiles) {
        let expectedResult = GenTestUtil.expectedTargetDirOutput(targetPath);
        for (let outF of outFiles) {
            expectedResult = expectedResult + GenTestUtil.expectedCreateOutput(outF);
        }
        chai.expect(output).equal(expectedResult);
    }
    static expectedCreateOutput(outF) {
        return '   create ' + outF + '\n';
    }
    static expectedIdenticalOutput(outF) {
        return 'identical ' + outF + '\n';
    }
    static expectedConflictOutput(outF) {
        return ' conflict ' + outF + '\n' + '    force ' + outF + '\n';
    }
    static expectedTargetDirOutput(targetPath) {
        return 'target dir = ' + path.resolve(targetPath) + '\n';
    }
    static checkIdenticalOutput(output, targetPath, ...outFiles) {
        let expectedResult = GenTestUtil.expectedTargetDirOutput(targetPath);
        for (let outF of outFiles) {
            expectedResult = expectedResult + GenTestUtil.expectedIdenticalOutput(outF);
        }
        chai.expect(output).equal(expectedResult);
    }
    static fullPath(targetPath, fileName) {
        return path.join(path.resolve(targetPath), fileName);
    }
    static exists(targetPath, fileName) {
        return fs.existsSync(GenTestUtil.fullPath(targetPath, fileName));
    }
    static cleanupGeneratedFiles(targetPath, genFiles) {
        try {
            for (let genFile of genFiles) {
                const filePath = GenTestUtil.fullPath(targetPath, genFile);
                if (fs.lstatSync(filePath).isDirectory()) {
                    fse.removeSync(filePath); // recursive remove
                }
                else {
                    fs.unlinkSync(filePath);
                }
            }
            if (targetPath) {
                fs.rmdirSync(targetPath);
            }
        }
        catch (err) {
            // TODO - normally just an indication that the files werent created
            // let zz = 'zz';
        }
    }
    static modifyFile(fileName) {
        let fsOpts = { flag: 'r', encoding: 'utf8' };
        let data = fs.readFileSync(fileName, fsOpts);
        fs.writeFileSync(fileName, 'modify' + data, { flag: 'w', encoding: 'utf8' });
    }
}
exports.GenTestUtil = GenTestUtil;
