"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const generator = require("yeoman-generator");
const generatorUtil_1 = require("../../common/main/generatorUtil");
const projectGeneratorInfo_1 = require("./projectGeneratorInfo");
const scratchDefGeneratorInfo_1 = require("../../scratchdef/main/scratchDefGeneratorInfo");
const artifactGeneratorInfo_1 = require("../../artifact/main/artifactGeneratorInfo");
const path = require("path");
const Messages = require("../../common/main/Messages");
const projectModule_1 = require("./projectModule");
const prettierGenerator_1 = require("../../prettier/main/prettierGenerator");
const vscodeGenerator_1 = require("../../vscode/main/vscodeGenerator");
class ProjectGenerator extends generator.Base {
    constructor(args, options) {
        super(args, options);
        this.genInfo = new projectGeneratorInfo_1.ProjectGeneratorInfo();
        // uses targetPath if set
        generatorUtil_1.GeneratorUtil.setPaths(__dirname, this, options);
        this.argument(projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_NAME_OPTION, {
            desc: Messages.get('ProjectNameOption'),
            required: false,
            type: 'String',
            defaults: ''
        });
        this.option(generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION, {
            desc: Messages.get('TemplateOption'),
            type: 'String',
            defaults: this.genInfo.getDefaultTemplate()
        });
        this.option(projectGeneratorInfo_1.ProjectGeneratorInfo.LOGIN_URL_OPTION, {
            desc: Messages.get('ProjectLoginOption'),
            type: 'String',
            defaults: this.genInfo.getDefaultLoginURL()
        });
        this.option(projectGeneratorInfo_1.ProjectGeneratorInfo.DEFAULT_PROJECT_OPTION, {
            desc: Messages.get('ProjectDefaultArtifactOption'),
            type: 'String',
            defaults: this.genInfo.getDefaultArtifactName()
        });
        this.option(projectGeneratorInfo_1.ProjectGeneratorInfo.NAMESPACE_OPTION, {
            desc: Messages.get('ProjectNamespaceOption'),
            type: 'String',
            defaults: ''
        });
        this.option(projectGeneratorInfo_1.ProjectGeneratorInfo.SCRATCH_ORG_DEF_OPTION, {
            desc: Messages.get('ProjectScratchOrgOption'),
            type: 'String',
            defaults: scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.DEFAULT_SCRATCHDEF_NAME
        });
        this.option(projectGeneratorInfo_1.ProjectGeneratorInfo.SOURCE_API_VERSION_OPTION, {
            desc: Messages.get('ProjectVersionOption'),
            type: 'String',
            defaults: this.genInfo.getDefaultSourceApiVersion()
        });
        this.option(projectGeneratorInfo_1.ProjectGeneratorInfo.MANIFEST_OPTION, {
            desc: Messages.get('ProjectManifestOption'),
            type: 'String'
        });
    }
    prompting() {
        let that = this;
        function x(answer) {
            that.projectName = answer[projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_NAME_OPTION];
        }
        if (!this.projectName) {
            return this.prompt({
                type: 'input',
                name: projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_NAME_OPTION,
                message: Messages.get('ProjectNamePrompt')
            }).then(answer => x(answer)); // type coercion due to the weak .d.ts for the base generator
        }
    }
    /**
     * everything goes into the projectName directory placed at the targetPath location
     * add README.md
     * add the sfdx-project.json file
     * add the config directory
     * add the manifest directory
     */
    writing() {
        const emptyTemplate = this.options[generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION] ===
            projectGeneratorInfo_1.ProjectGeneratorInfo.EMPTY_TEMPLATE;
        this.fs.copyTpl(this.templatePath(projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_CONFIG_NAME), this.destinationPath(path.join(this.projectName, projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_CONFIG_NAME)), {
            loginURL: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.LOGIN_URL_OPTION],
            sourceApiVersion: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.SOURCE_API_VERSION_OPTION],
            defaultArtifact: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.DEFAULT_PROJECT_OPTION],
            namespace: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.NAMESPACE_OPTION],
            scratchOrgDef: path.join(scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.SCRATCHDEF_CONFIG_FOLDER, this.options['scratchOrgDef'])
        });
        this.fs.copyTpl(this.templatePath(emptyTemplate
            ? projectGeneratorInfo_1.ProjectGeneratorInfo.README_EMPTY
            : projectGeneratorInfo_1.ProjectGeneratorInfo.README_STANDARD), this.destinationPath(path.join(this.projectName, projectGeneratorInfo_1.ProjectGeneratorInfo.README)), {});
        this.fs.copyTpl(this.templatePath(projectGeneratorInfo_1.ProjectGeneratorInfo.FORCE_IGNORE), this.destinationPath(path.join(this.projectName, projectGeneratorInfo_1.ProjectGeneratorInfo.FORCE_IGNORE)), {});
        if (!emptyTemplate) {
            this.fs.copyTpl(this.templatePath(projectGeneratorInfo_1.ProjectGeneratorInfo.GIT_IGNORE_TEMPLATE), this.destinationPath(path.join(this.projectName, projectGeneratorInfo_1.ProjectGeneratorInfo.GIT_IGNORE)), {});
        }
        // remove targetPath since the first setPaths changes the cwd already
        // but messing with the destinationRoot is needed to ensure that the right text output comes out
        //    not needed to get the created files in the right place
        const initialTargetPath = this.destinationRoot();
        this.composeWith('force:artifact', {
            arguments: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.DEFAULT_PROJECT_OPTION],
            options: {
                [generatorUtil_1.GeneratorUtil.PATH_OPTION]: this.projectName,
                [generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION]: this.options[generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION],
                [artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_DEFAULT_OPTION]: 'true'
            }
        });
        this.destinationRoot(initialTargetPath);
        this.composeWith('force:scratchdef', {
            arguments: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.SCRATCH_ORG_DEF_OPTION],
            options: {
                [scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.EMAIL_OPTION]: scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.getUserName + '@example.com',
                [generatorUtil_1.GeneratorUtil.PATH_OPTION]: this.projectName
            }
        });
        this.destinationRoot(initialTargetPath);
        if (this.options[projectModule_1.ProjectModule.MANIFEST_FLAG]) {
            this.composeWith('force:manifest', {
                options: {
                    [generatorUtil_1.GeneratorUtil.PATH_OPTION]: this.projectName,
                    sourceApiVersion: this.options[projectGeneratorInfo_1.ProjectGeneratorInfo.SOURCE_API_VERSION_OPTION]
                }
            });
            this.destinationRoot(initialTargetPath);
        }
        if (!emptyTemplate) {
            this.composeWith(vscodeGenerator_1.VSCodeGenerator.GENERATOR_NAME, {
                options: {
                    [generatorUtil_1.GeneratorUtil.PATH_OPTION]: this.projectName,
                    prettier: true,
                    eslint: true
                }
            });
            this.destinationRoot(initialTargetPath);
            this.composeWith(prettierGenerator_1.PrettierGenerator.GENERATOR_NAME, {
                options: {
                    [generatorUtil_1.GeneratorUtil.PATH_OPTION]: this.projectName
                }
            });
            this.destinationRoot(initialTargetPath);
        }
    }
}
ProjectGenerator.GENERATOR_NAME = 'force:project';
exports.ProjectGenerator = ProjectGenerator;

//# sourceMappingURL=projectGenerator.js.map
