"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const generator = require("yeoman-generator");
const generatorUtil_1 = require("../../common/main/generatorUtil");
const artifactGeneratorInfo_1 = require("./artifactGeneratorInfo");
const projectGeneratorInfo_1 = require("../../project/main/projectGeneratorInfo");
const mkdirp = require("mkdirp");
const path = require("path");
const Messages = require("../../common/main/Messages");
const configuration_1 = require("../../common/main/configuration");
const eslintGenerator_1 = require("../../eslint/main/eslintGenerator");
class ArtifactGenerator extends generator.Base {
    constructor(args, options) {
        super(args, options);
        this.genInfo = new artifactGeneratorInfo_1.ArtifactGeneratorInfo();
        // uses targetPath if set
        generatorUtil_1.GeneratorUtil.setPaths(__dirname, this, options);
        this.argument(artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_NAME_OPTION, {
            desc: Messages.get('ArtifactNameOption'),
            required: false,
            type: 'String',
            defaults: ''
        });
        this.option(artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_VERSION_OPTION, {
            desc: Messages.get('ArtifactVersionOption'),
            type: 'String',
            defaults: artifactGeneratorInfo_1.ArtifactGeneratorInfo.VERSION_DEFAULT
        });
        this.option(artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_DESCRIPTION_OPTION, {
            desc: Messages.get('ArtifactDescriptionOption'),
            type: 'String',
            defaults: ''
        });
        this.option(artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_DEFAULT_OPTION, {
            desc: Messages.get('ArtifactMakeDefaultOption'),
            type: 'String',
            defaults: ''
        });
        this.option(generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION, {
            desc: Messages.get('TemplateOption'),
            type: 'String',
            defaults: this.genInfo.getDefaultTemplate()
        });
    }
    // TODO - get this from the proper config setting
    // create a simple project otherwise
    createArtifact() {
        return configuration_1.Configuration.allowArtifacts();
    }
    prompting() {
        let that = this;
        function x(answer) {
            that.artifactName = answer[artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_NAME_OPTION];
        }
        if (!this.artifactName) {
            return this.prompt({
                type: 'input',
                name: artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_NAME_OPTION,
                message: Messages.get('ArtifactNamePrompt')
            }).then(answer => x(answer)); // type coercion due to the weak .d.ts for the base generator
        }
    }
    // put underscore in front of all private support functions
    // otherwise the yeoman generator system will try to run these independently
    // adapted from force-com-toolbelt projectDir.js
    // have to use this.fs to deal with the yeoman in memory file system
    // should be revisited after future refactoring to inject the fs method
    _traverseForFile(workingDir, fileName) {
        if (this.fs.exists(path.join(workingDir, fileName))) {
            return workingDir;
        }
        else {
            const indexOfLastSlash = workingDir.lastIndexOf(path.sep);
            if (indexOfLastSlash > 0) {
                return this._traverseForFile(workingDir.substring(0, indexOfLastSlash), fileName);
            }
            else {
                return '';
            }
        }
    }
    // when called from the workspace generator, the artifact folder will always just be one level below the workspace dir
    // but should allow for creating artifacts in other locations and adding them to this workspace
    _getWorkspaceDir() {
        return this._traverseForFile(this.destinationPath(), projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_CONFIG_NAME);
    }
    // only allow relative enclosed path for now
    // TODO should be checked earlier before calling the generator
    _getArtifactPath(workspaceDir, artifactPath) {
        return path.relative(workspaceDir, artifactPath);
    }
    _addArtifactToConfig(workspaceDir, artifactName, makeDefault) {
        let artifactPath = this.destinationPath(artifactName);
        let configFilePath = path.join(workspaceDir, projectGeneratorInfo_1.ProjectGeneratorInfo.PROJECT_CONFIG_NAME);
        let configFile = this.fs.read(configFilePath, 'utf-8');
        let config = JSON.parse(configFile);
        if (makeDefault) {
            // remove Default from an earlier element
            config.packageDirectories.forEach((pkgDir, index) => {
                if (pkgDir.default) {
                    config.packageDirectories[index].default = undefined;
                }
            });
        }
        let newArtifact = {
            path: this._getArtifactPath(workspaceDir, artifactPath)
        };
        if (makeDefault) {
            newArtifact.default = true;
        }
        config.packageDirectories.push(newArtifact);
        this.fs.writeJSON(configFilePath, config);
    }
    writing() {
        let workspaceDir = this._getWorkspaceDir();
        if (!workspaceDir) {
            // don't create the artifact, apparently not in a valid workspace currently
            // revisit this when/if artifacts are allowed to be outside the workspace folders
            // in that case, the workspaceDir will need to be provided as a flag
            return;
        }
        // remove targetPath since the first setPaths changes the cwd already
        // but messing with the destinationRoot is needed to ensure that the right text output comes out
        //    not needed to get the created files in the right place
        const initialTargetPath = this.destinationRoot();
        if (this.createArtifact()) {
            this.fs.copyTpl(this.templatePath(artifactGeneratorInfo_1.ArtifactGeneratorInfo.VERSION_DESCRIPTOR), this.destinationPath(path.join(this.artifactName, artifactGeneratorInfo_1.ArtifactGeneratorInfo.VERSION_DESCRIPTOR)), {
                artifactName: this.artifactName,
                version: this.options[artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_VERSION_OPTION],
                description: this.options[artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_DESCRIPTION_OPTION]
            });
        }
        mkdirp.sync(this.destinationPath(path.join(this.artifactName, artifactGeneratorInfo_1.ArtifactGeneratorInfo.SRC_FOLDER)));
        const isEmptyTemplate = this.options[generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION] ===
            projectGeneratorInfo_1.ProjectGeneratorInfo.EMPTY_TEMPLATE;
        const folderList = isEmptyTemplate
            ? artifactGeneratorInfo_1.ArtifactGeneratorInfo.EMPTY_TEMPLATE_METADATA_FOLDERS
            : artifactGeneratorInfo_1.ArtifactGeneratorInfo.METADATA_FOLDERS;
        folderList.forEach(folder => {
            mkdirp.sync(this.destinationPath(path.join(this.artifactName, artifactGeneratorInfo_1.ArtifactGeneratorInfo.SRC_FOLDER, folder)));
        });
        if (!isEmptyTemplate &&
            folderList.indexOf(artifactGeneratorInfo_1.ArtifactGeneratorInfo.LWC_FOLDER) > -1) {
            this.composeWith(eslintGenerator_1.ESLintGenerator.GENERATOR_NAME, {
                options: {
                    [generatorUtil_1.GeneratorUtil.PATH_OPTION]: this.destinationPath(path.join(this.artifactName, artifactGeneratorInfo_1.ArtifactGeneratorInfo.SRC_FOLDER, artifactGeneratorInfo_1.ArtifactGeneratorInfo.LWC_FOLDER)),
                    [generatorUtil_1.GeneratorUtil.TEMPLATE_OPTION]: artifactGeneratorInfo_1.ArtifactGeneratorInfo.LWC_FOLDER
                }
            });
            this.destinationRoot(initialTargetPath);
        }
        // add the artifact to sfdx-project.json
        this._addArtifactToConfig(workspaceDir, this.artifactName, this.options[artifactGeneratorInfo_1.ArtifactGeneratorInfo.ARTIFACT_DEFAULT_OPTION] !== undefined);
    }
}
ArtifactGenerator.GENERATOR_NAME = 'force:artifact';
exports.ArtifactGenerator = ArtifactGenerator;

//# sourceMappingURL=artifactGenerator.js.map
