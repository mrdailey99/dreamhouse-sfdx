"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const scratchDefGenerator_1 = require("./scratchDefGenerator");
const createBase_1 = require("../../common/main/createBase");
const generatorUtil_1 = require("../../common/main/generatorUtil");
const commandUtil_1 = require("../../common/main/commandUtil");
const scratchDefGeneratorInfo_1 = require("./scratchDefGeneratorInfo");
const Messages = require("../../common/main/Messages");
class ScratchDefModule {
    static getFlagMap() {
        let flagMap = new Map();
        flagMap.set(ScratchDefModule.COMPANY_FLAG, scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.COMPANY_OPTION);
        flagMap.set(ScratchDefModule.LAST_NAME_FLAG, scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.LAST_NAME_OPTION);
        flagMap.set(ScratchDefModule.EMAIL_FLAG, scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.EMAIL_OPTION);
        return flagMap;
    }
    /**
     * @param {scratchDefName} - name of the new workspace
     * @param {targetPath} - where to generate the workspace
     * @param (options) - available options (to be documented)
     *     should allow config - which is a json file with all the options in a decision tree form)
     */
    // NOTE: the yeoman generator changes the actual cwd when the destinationRoot is set 
    //       and too many things in there assume that
    //       so if there is a target path, reset the cwd after done running the generator
    create(scratchDefName, targetPath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const generatorName = 'force:scratchdef';
            let addGenerators = function (env) {
                env.registerStub(scratchDefGenerator_1.ScratchDefGenerator, generatorName);
            };
            let checkInputs = function () {
                let templateName = options['template'];
                // ?? TODO check for valid scratch def name - are there any restrictions
                //const checkNameResult = GeneratorUtil.checkName(apiName);
                //if (checkNameResult.length > 0) {
                //    return checkNameResult;
                //}
                // TODO - check for valid login URL???
                if (templateName) {
                    if (!ScratchDefModule.genInfo.isValidTemplate(templateName)) {
                        return Messages.get('InvalidTemplate');
                    }
                }
                // TODO check other inputs ?
                return '';
            };
            let createOptions = options;
            createOptions[scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo.SCRATCH_DEF_NAME_OPTION] = scratchDefName;
            let rawOutput = yield new createBase_1.CreateBase().create(scratchDefName, targetPath, createOptions, generatorName, checkInputs, addGenerators);
            if (options['json']) {
                return generatorUtil_1.GeneratorUtil.jsonOutput(rawOutput);
            }
            else {
                return rawOutput;
            }
        });
    }
    static getNameFlagName() {
        return 'scratchdefconfig' + commandUtil_1.CommandUtil.NAME_FLAG;
    }
    static getPathFlagName() {
        return commandUtil_1.CommandUtil.PATH_FLAG;
    }
    static reflectCreate() {
        let reflect = { flags: {} };
        generatorUtil_1.GeneratorUtil.addNameFlag(reflect, ScratchDefModule.getNameFlagName(), Messages.get('ScratchDefNameFlagDescription'), Messages.get('ScratchDefNameFlagLongDescription'));
        generatorUtil_1.GeneratorUtil.addCommonFlags2(reflect, ScratchDefModule.genInfo.getTemplates(), ScratchDefModule.genInfo.getDefaultTemplate());
        generatorUtil_1.GeneratorUtil.addFlag(reflect, {
            name: ScratchDefModule.COMPANY_FLAG, char: 'y', hasValue: true, required: false,
            description: Messages.get('ScratchDefCompanyFlagDescription'),
            longDescription: Messages.get('ScratchDefCompanyFlagLongDescription'),
        }, [], ScratchDefModule.genInfo.getDefaultCompanyName());
        generatorUtil_1.GeneratorUtil.addFlag(reflect, {
            name: ScratchDefModule.LAST_NAME_FLAG, char: 'l', hasValue: true, required: false,
            description: Messages.get('ScratchDefLastNameFlagDescription'),
            longDescription: Messages.get('ScratchDefLastNameFlagLongDescription'),
        }, [], ScratchDefModule.genInfo.getDefaultLastName());
        generatorUtil_1.GeneratorUtil.addFlag(reflect, {
            name: ScratchDefModule.EMAIL_FLAG, char: 'e', hasValue: true, required: false,
            description: Messages.get('ScratchDefEmailFlagDescription'),
            longDescription: Messages.get('ScratchDefEmailFlagLongDescription'),
        }, []);
        return reflect;
    }
}
ScratchDefModule.genInfo = new scratchDefGeneratorInfo_1.ScratchDefGeneratorInfo();
ScratchDefModule.COMPANY_FLAG = 'company';
ScratchDefModule.LAST_NAME_FLAG = 'lastname';
ScratchDefModule.EMAIL_FLAG = 'email';
exports.ScratchDefModule = ScratchDefModule;
;

//# sourceMappingURL=scratchDefModule.js.map
